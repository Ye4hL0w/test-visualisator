# Configuration du proxy SPARQL pour VisGraph

## üéØ Quand cr√©er un proxy ?

Le composant VisGraph fonctionne selon cette hi√©rarchie :

1. **JSON direct** ‚úÖ ‚Üí Aucune configuration requise
2. **Endpoint SPARQL direct** ‚úÖ ‚Üí Fonctionne si l'endpoint supporte CORS  
3. **Proxy SPARQL** üîß ‚Üí Configuration requise (ce guide)

**Cr√©ez le fichier `js/proxy.js` seulement si** vous voyez ces erreurs CORS dans la console :
```
‚ùå [VisGraph] √âchec avec endpoint direct: TypeError: Failed to fetch
üö´ [VisGraph] Probl√®me de CORS d√©tect√©
```

## üöÄ Solution rapide : Cr√©er le fichier proxy.js

### √âtape 1 : Cr√©er le fichier js/proxy.js

Dans votre projet web, cr√©ez le fichier `js/proxy.js` avec ce contenu :

```javascript
// Configuration du proxy SPARQL pour VisGraph
const PROXY_CONFIG = {
  // Option 1: CORS Anywhere (pour les tests)
  corsAnywhereUrl: 'https://cors-anywhere.herokuapp.com/',
  
  // Option 2: AllOrigins (service gratuit)
  allOriginsUrl: 'https://api.allorigins.win/get?url=',
  
  // Option 3: Votre propre proxy (si vous en avez un)
  customProxyUrl: 'https://votre-proxy.com/sparql-proxy',
  
  // M√©thode pr√©f√©r√©e (essayez dans cet ordre)
  preferredMethod: 'allorigins', // 'allorigins', 'cors-anywhere', ou 'custom'
  
  // Timeout en millisecondes
  timeout: 30000
};

/**
 * Interface du proxy pour VisGraph
 */
export default {
  
  async query(endpoint, sparqlQuery) {
    console.log('[Proxy] Tentative de requ√™te via proxy');
    
    const methods = {
      'allorigins': () => this.queryViaAllOrigins(endpoint, sparqlQuery),
      'cors-anywhere': () => this.queryViaCorsAnywhere(endpoint, sparqlQuery),
      'custom': () => this.queryViaCustomProxy(endpoint, sparqlQuery)
    };
    
    // Essayer la m√©thode pr√©f√©r√©e d'abord
    try {
      if (methods[PROXY_CONFIG.preferredMethod]) {
        console.log(`[Proxy] Utilisation de ${PROXY_CONFIG.preferredMethod}`);
        return await methods[PROXY_CONFIG.preferredMethod]();
      }
    } catch (error) {
      console.warn(`[Proxy] √âchec avec ${PROXY_CONFIG.preferredMethod}:`, error.message);
    }
    
    // Essayer les autres m√©thodes en fallback
    for (const [methodName, method] of Object.entries(methods)) {
      if (methodName === PROXY_CONFIG.preferredMethod) continue;
      
      try {
        console.log(`[Proxy] Tentative avec ${methodName}`);
        return await method();
      } catch (error) {
        console.warn(`[Proxy] √âchec avec ${methodName}:`, error.message);
      }
    }
    
    throw new Error('Toutes les m√©thodes de proxy ont √©chou√©');
  },
  
  // M√©thode 1: AllOrigins (recommand√© pour commencer)
  async queryViaAllOrigins(endpoint, sparqlQuery) {
    const params = new URLSearchParams({
      query: sparqlQuery,
      format: 'json'
    });
    
    const targetUrl = `${endpoint}?${params.toString()}`;
    const proxyUrl = PROXY_CONFIG.allOriginsUrl + encodeURIComponent(targetUrl);
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), PROXY_CONFIG.timeout);
    
    try {
      const response = await fetch(proxyUrl, {
        method: 'GET',
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw new Error(`AllOrigins error: ${response.status}`);
      }
      
      const result = await response.json();
      return JSON.parse(result.contents);
    } catch (error) {
      clearTimeout(timeoutId);
      throw error;
    }
  },
  
  // M√©thode 2: CORS Anywhere (peut √™tre indisponible)
  async queryViaCorsAnywhere(endpoint, sparqlQuery) {
    const proxyUrl = PROXY_CONFIG.corsAnywhereUrl + endpoint;
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), PROXY_CONFIG.timeout);
    
    try {
      const response = await fetch(proxyUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Requested-With': 'XMLHttpRequest'
        },
        body: new URLSearchParams({
          query: sparqlQuery,
          format: 'json'
        }),
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw new Error(`CORS Anywhere error: ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      clearTimeout(timeoutId);
      throw error;
    }
  },
  
  // M√©thode 3: Proxy personnalis√© (si vous en avez un)
  async queryViaCustomProxy(endpoint, sparqlQuery) {
    if (!PROXY_CONFIG.customProxyUrl) {
      throw new Error('URL du proxy personnalis√© non configur√©e');
    }
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), PROXY_CONFIG.timeout);
    
    try {
      const response = await fetch(PROXY_CONFIG.customProxyUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          endpoint: endpoint,
          query: sparqlQuery,
          format: 'json'
        }),
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Proxy error ${response.status}: ${errorText}`);
      }
      
      return await response.json();
    } catch (error) {
      clearTimeout(timeoutId);
      throw error;
    }
  }
};
```

### √âtape 2 : Tester votre configuration

Une fois le fichier cr√©√©, testez dans votre console navigateur :

```javascript
// Test simple
const graphComponent = document.querySelector('vis-graph');

const endpoint = 'https://dbpedia.org/sparql';
const query = `
  SELECT DISTINCT ?person ?name WHERE {
    ?person a dbo:Person ;
            rdfs:label ?name .
    FILTER(LANG(?name) = "en")
  } LIMIT 5
`;

graphComponent.loadFromSparqlEndpoint(endpoint, query)
  .then(result => {
    console.log('‚úÖ Proxy fonctionne !', result);
  })
  .catch(error => {
    console.error('‚ùå Proxy ne fonctionne pas:', error);
  });
```

## üîß Personnalisation du proxy

### Changer la m√©thode pr√©f√©r√©e

Dans `js/proxy.js`, modifiez la ligne :

```javascript
preferredMethod: 'allorigins', // Changez ici
```

Options disponibles :
- `'allorigins'` - Service gratuit, g√©n√©ralement fiable
- `'cors-anywhere'` - Peut √™tre indisponible, pour les tests
- `'custom'` - Si vous avez votre propre serveur proxy

### Ajouter votre propre proxy

Si vous avez un serveur proxy, modifiez :

```javascript
customProxyUrl: 'https://votre-proxy.herokuapp.com/sparql-proxy',
preferredMethod: 'custom'
```

### Ajuster le timeout

Pour des requ√™tes plus longues :

```javascript
timeout: 60000 // 60 secondes au lieu de 30
```

## üìä Format de donn√©es attendu par le composant

Le composant VisGraph attend un **format JSON SPARQL standard**. Votre proxy doit retourner exactement ce format :

### Structure JSON attendue

```json
{
  "head": {
    "vars": ["variable1", "variable2", "variable3"]
  },
  "results": {
    "bindings": [
      {
        "variable1": {
          "type": "uri",
          "value": "http://example.org/resource1"
        },
        "variable2": {
          "type": "literal",
          "value": "Texte ou label"
        },
        "variable3": {
          "type": "uri", 
          "value": "http://example.org/resource2"
        }
      }
    ]
  }
}
```

### Exemple concret pour un graphe

**Requ√™te SPARQL:**
```sparql
SELECT ?gene ?geneLabel ?protein WHERE {
  ?gene a :Gene ;
        rdfs:label ?geneLabel ;
        :encodes ?protein .
} LIMIT 5
```

**JSON retourn√© par votre proxy:**
```json
{
  "head": {
    "vars": ["gene", "geneLabel", "protein"]
  },
  "results": {
    "bindings": [
      {
        "gene": {
          "type": "uri",
          "value": "http://example.org/gene/BRCA1"
        },
        "geneLabel": {
          "type": "literal",
          "value": "BRCA1 gene"
        },
        "protein": {
          "type": "uri",
          "value": "http://example.org/protein/P38398"
        }
      },
      {
        "gene": {
          "type": "uri", 
          "value": "http://example.org/gene/TP53"
        },
        "geneLabel": {
          "type": "literal",
          "value": "TP53 tumor protein"
        },
        "protein": {
          "type": "uri",
          "value": "http://example.org/protein/P04637"
        }
      }
    ]
  }
}
```

### Ce que fait le composant avec ces donn√©es

1. **Variables** (`head.vars`) ‚Üí Identifie les colonnes source/target
2. **Bindings** (`results.bindings`) ‚Üí Chaque ligne devient un n≈ìud/lien
3. **Types** (`type: "uri"` ou `"literal"`) ‚Üí D√©termine le traitement
4. **Values** (`value`) ‚Üí Contenu affich√© et URIs pour les d√©tails

### Transformation en graphe

Le composant transforme automatiquement :

- **Premi√®re variable** (`gene`) ‚Üí **N≈ìuds sources**
- **Deuxi√®me variable** (`protein`) ‚Üí **N≈ìuds cibles** 
- **Autres variables** (`geneLabel`) ‚Üí **Labels et m√©tadonn√©es**
- **Relations** ‚Üí **Liens entre source et target**

### Types de valeurs support√©s

| Type SPARQL | Description | Utilisation |
|-------------|-------------|-------------|
| `"uri"` | Ressource avec URL | N≈ìuds, liens, d√©tails suppl√©mentaires |
| `"literal"` | Texte simple | Labels, descriptions, nombres |
| `"bnode"` | N≈ìud blanc | N≈ìuds anonymes (rare) |

### M√©tadonn√©es optionnelles

Le composant peut aussi utiliser :

```json
{
  "variable": {
    "type": "literal",
    "value": "Texte",
    "xml:lang": "en",        // Langue (optionnel)
    "datatype": "xsd:string" // Type de donn√©es (optionnel)
  }
}
```

### ‚ö†Ô∏è Erreurs courantes √† √©viter

1. **Mauvais format JSON** ‚Üí Le composant plantera
2. **Variables manquantes** ‚Üí Graphe vide
3. **Types incorrects** ‚Üí N≈ìuds mal interpr√©t√©s
4. **Values vides** ‚Üí N≈ìuds sans label

### ‚úÖ Test de validation

Pour v√©rifier que votre proxy retourne le bon format :

```javascript
// Dans la console navigateur
fetch('votre-proxy-url', {
  method: 'POST',
  body: JSON.stringify({
    endpoint: 'https://dbpedia.org/sparql',
    query: 'SELECT ?s ?p ?o WHERE { ?s ?p ?o } LIMIT 1'
  })
})
.then(response => response.json())
.then(data => {
  console.log('‚úÖ Structure valide:', data.head && data.results);
  console.log('üìä Variables:', data.head?.vars);
  console.log('üìã Bindings:', data.results?.bindings?.length);
});
```

## üß™ Validation

### Dans la console du navigateur

Vous devriez voir ces messages si tout fonctionne :

```
üîç [VisGraph] R√©cup√©ration des donn√©es depuis l'endpoint...
‚ùå [VisGraph] √âchec avec endpoint direct: TypeError: Failed to fetch
üîç [VisGraph] Tentative 2: Proxy
[Proxy] Tentative de requ√™te via proxy
[Proxy] Utilisation de allorigins
‚úÖ [VisGraph] Succ√®s avec proxy
```

### Structure de fichiers

Votre projet doit avoir cette structure :

```
votre-projet/
‚îú‚îÄ‚îÄ js/
‚îÇ   ‚îî‚îÄ‚îÄ proxy.js          ‚Üê Le fichier que vous venez de cr√©er
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ VisGraph.js       ‚Üê Le composant (d√©j√† fourni)
‚îî‚îÄ‚îÄ index.html            ‚Üê Votre page web
```

## üö® Probl√®mes courants

### "Proxy non disponible"
- V√©rifiez que le fichier `js/proxy.js` existe bien
- V√©rifiez qu'il n'y a pas d'erreurs de syntaxe

### "Toutes les m√©thodes ont √©chou√©"
- Essayez de changer `preferredMethod` de `'allorigins'` √† `'cors-anywhere'`
- V√©rifiez votre connexion internet

### "Module proxy non trouv√©" 
- Assurez-vous que le chemin est correct : `/js/proxy.js`
- V√©rifiez que votre serveur web sert bien les fichiers du dossier `js/`

## üí° Conseils

1. **Commencez simple** : Utilisez le code fourni tel quel d'abord
2. **Testez d'abord AllOrigins** : C'est g√©n√©ralement le plus fiable
3. **Gardez CORS Anywhere en fallback** : Au cas o√π AllOrigins serait indisponible
4. **Surveillez la console** : Les messages vous diront exactement ce qui se passe

---

**üéâ C'est tout !** Votre composant VisGraph peut maintenant contourner les restrictions CORS. 